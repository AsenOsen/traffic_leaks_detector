package detector.NetwPrimitives;

import detector.DB_OsProcessesInfo;
import detector.OsProcessesPrimitives.NetProcess;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

/*************************************************************************
 * This class contains a single traffic flow.
 * Its instance can be bounded to:
*    1) IP
*    2) Port
*    3) Process
*    4) ...
* ***********************************************************************/
public class TrafficFlow {

    private volatile int totalPayload = 0;
    private int processedPackets = 0;      // amount of addPayload() calls
    private long startMillis = 0;          // time when the first byte was added
    private long lastActMillis = 0;        // time of the last AddBytes() call

    private ConcurrentMap<IPv4Address, Integer> ipsPayload   // payload in bytes of each detected DST IPs
            = new ConcurrentHashMap<IPv4Address, Integer>(32);
    private ConcurrentMap<Port, Integer> portsPayload        // payload in bytes of each detected SRC PORTs
            = new ConcurrentHashMap<Port, Integer>(32);
    //private ConcurrentMap<NetProcess, Integer> psPayload     // payload in bytes of each detected OS Process
    //        = new ConcurrentHashMap<NetProcess, Integer>(4);


    public TrafficFlow()
    {
        startMillis = System.currentTimeMillis();
    }


    /*
    * Adds new packet to a traffic flow
    * */
    public synchronized void addPayload(Packet additional)
    {
        if(totalPayload == 0)
            startMillis = System.currentTimeMillis();
        lastActMillis = System.currentTimeMillis();

        increaseTraffic(additional);
    }


    /*
    * Merges one TrafficFlow instance with another
    * */
    public synchronized void mergeWith(TrafficFlow traffic)
    {
        totalPayload += traffic.totalPayload;
        processedPackets += traffic.processedPackets;
        startMillis = Math.min(startMillis, traffic.startMillis);
        lastActMillis = Math.max(lastActMillis, traffic.lastActMillis);

        for(IPv4Address ip : traffic.ipsPayload.keySet())
        {
            ipsPayload.putIfAbsent(ip, 0);
            ipsPayload.put(ip, ipsPayload.get(ip) + traffic.ipsPayload.get(ip));
        }
        for(Port port : traffic.portsPayload.keySet())
        {
            portsPayload.putIfAbsent(port, 0);
            portsPayload.put(port, portsPayload.get(port) + traffic.portsPayload.get(port));
        }
    }


    /*
    *  Extracts from packet`s header an additional data.
     * This is needed for storing the information about
     * active ports/IPs/etc. for traffic flow.
    * */
    private void increaseTraffic(Packet packet)
    {
        IPv4Address destPacketIp = packet.getDestinationAddress();
        Port srcPacketPort = packet.getSourcePort();
        int payload = packet.getPayloadSize();

        totalPayload += payload;
        processedPackets++;

        ipsPayload.putIfAbsent(destPacketIp, 0);
        ipsPayload.put(destPacketIp, ipsPayload.get(destPacketIp)+payload);

        portsPayload.putIfAbsent(srcPacketPort, 0);
        portsPayload.put(srcPacketPort, portsPayload.get(srcPacketPort)+payload);
    }


    /*
    * Return total payload of a traffic flow in bytes
    * */
    public int getBytes()
    {
        return totalPayload;
    }


    /*
    * Returns the time of monitoring specific traffic
    * */
    public float getInactivityTimeSec()
    {
        return (System.currentTimeMillis() - lastActMillis) / 1000f;
    }


    /*
    * Return time in seconds during which traffic have been collected
    * */
    public float getUpTimeSec()
    {
        return (lastActMillis - startMillis) / 1000f;
    }


    /*
    * Returns the destination IP traffic was mostly generated by
    * */
    public IPv4Address getDominantDstAddr()
    {
        // Check each DST IP on dominance
        for(IPv4Address member : ipsPayload.keySet())
            if(ipsPayload.get(member) >= getDominancePayloadSize())
                return member;

        return null;
    }


    /*
    * Returns the source PORT traffic was mostly generated by
    * */
    public Port getDominantSrcPort()
    {
        // Check each SRC PORT on dominance
        for(Port member : portsPayload.keySet())
            if(portsPayload.get(member) >= getDominancePayloadSize())
                return member;

        return null;
    }


    /*
    * Returns most probable process-initiator of the traffic flow
    * */
    public NetProcess getDominantProcess()
    {
        HashMap<NetProcess, Integer> processPayload = new HashMap<NetProcess, Integer>();

        // make up table NetProcess -> trafficFlow
        for(Map.Entry<Port, Integer> entry : portsPayload.entrySet())
        {
            NetProcess portOwner = entry.getKey().getOwnerProcess();
            if(portOwner == null)
                continue;

            Integer payload = entry.getValue();
            if( processPayload.containsKey(portOwner) )
                processPayload.put(portOwner, processPayload.get(portOwner) + payload);
            else
                processPayload.put(portOwner, payload);
        }

        int maxDetectedTraffic = Integer.MIN_VALUE;
        NetProcess probableInitiator = null;

        // pick the process with the biggest trafficFlow
        for(Map.Entry<NetProcess, Integer> entry : processPayload.entrySet())
        {
            if(entry.getValue() > maxDetectedTraffic)
            {
                maxDetectedTraffic = entry.getValue();
                probableInitiator = entry.getKey();
            }
        }

        // probableInitiator`s traffic MUST be dominant in entire traffic flow
        return maxDetectedTraffic >= getDominancePayloadSize() ?
                probableInitiator : null;
    }


    private float getDominancePayloadSize()
    {
        // More than 40% of all traffic was generated by single element
        return totalPayload * 0.4f;
    }


    @Override
    public String toString() {

        StringBuilder meanIps = new StringBuilder();
        StringBuilder meanPorts = new StringBuilder();

        for(IPv4Address ip : ipsPayload.keySet())
                meanIps.append(ip+"("+ipsPayload.get(ip)+"b), ");
        for(Port port : portsPayload.keySet())
                meanPorts.append(port+"("+portsPayload.get(port)+"b)"+
                        DB_OsProcessesInfo.getInstance().getProcessOfPort(port)+", ");

        float speedKbPerSec = (totalPayload / getUpTimeSec()) / 1024f;
        //String type = speedKbPerSec > 30f ? "Отправка накопленных данных" : "Real-Time отправка";

        IPv4Address dominant = getDominantDstAddr();

        return "KBytes: "+(totalPayload/1024d)+" | "+
                "AvgPacketSize(b): "+((float)totalPayload/ processedPackets)+" | "+
                "Uptime(s): "+getUpTimeSec()+" | "+
                //"\nType: "+type+
                "\nDst's: "+meanIps+
                "\nSrc's: "+meanPorts+
                "\nDstDom: "+ (dominant == null ? "null" : dominant.getIpInfo())+
                "\nSrcDom: "+ getDominantSrcPort();
    }

}
