using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace gui
{
    /*
     * 
     * Contract:
     * This class DOES NOT return NULL-values.
     * 
     */
    public class ServerMessage
    {

        JObject msgObject = null;
        String serverMessage = null;

        // start of json object
        String messageFull = null;
        String messageExciter = null;
        String messageType = null;
        String callbackFilter = null;
        DateTime time = DateTime.Now;
        // end of json object

        int messageLaggingTime = 0;


        public ServerMessage(String message)
        {
            this.serverMessage = message;
            Parse();
        }


        public bool isValid()
        {
            return
                (messageFull != null && messageFull.Length>0) || 
                (messageExciter != null && messageExciter.Length>0) || 
                (messageType != null && messageType.Length>0);
        }


        public String getMessage()
        {
            return messageFull == null ? "" : messageFull;
        }


        public String getCause()
        {
            return messageExciter == null ? "" : messageExciter;
        }


        public String getLeakType()
        {
            return messageType == null ? "" : messageType;
        }


        public String getCallbackFilter()
        {
            return callbackFilter == null ? "" : callbackFilter;
        }


        public DateTime getMessageTime()
        {
            return time;
        }


        // Checks if message was generated by daemon not so long ago
        public bool isActual()
        {
            return messageLaggingTime <= 10;
        }


        private void Parse()
        {
            try
            {
                this.msgObject = JObject.Parse(serverMessage);
            }
            catch (JsonException)
            {
                // broken json format
                Debug.Assert(false, "Broken JSON!");
                return;
            }

            // parsing... 
            if (msgObject["message_full"] != null)
                this.messageFull = msgObject["message_full"].ToString().Trim();
            if (msgObject["message_exciter"] != null)
                this.messageExciter = msgObject["message_exciter"].ToString().Trim();
            if (msgObject["message_type"] != null)
                this.messageType = msgObject["message_type"].ToString().Trim();
            if (msgObject["callback_filter"] != null)
                this.callbackFilter = msgObject["callback_filter"].ToString().Trim();
            if (msgObject["utc_timestamp"] != null)
                this.time = getMessageBirthTime(msgObject["utc_timestamp"].ToString().Trim());

        }


        private DateTime getMessageBirthTime(String serverUtcTimestamp)
        {
            long clientTimestamp = (long)(DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1))).TotalSeconds;
            long serverTimestamp = 0;
            if (serverUtcTimestamp!=null && long.TryParse(serverUtcTimestamp, out serverTimestamp))
            {
                this.messageLaggingTime = (int)(clientTimestamp - serverTimestamp);
                return DateTime.Now.Subtract(new TimeSpan(0, 0, messageLaggingTime)).ToLocalTime();
            }

            // just current time
            return DateTime.Now.ToLocalTime(); 
        }

    }
}
